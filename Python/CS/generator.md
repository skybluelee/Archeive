# 제너레이터
특정 변수를 반환하는 함수가 있고, 해당 함수가 끝나는데 시간이 오래 걸린다. 반환하는 변수를 필요로 하는 또 다른 함수는 해당 함수가 끝날 때까지 반드시 기다려야 한다.

이 점을 보완하기 위해 만든 것이 제너레이터 함수이며 `return` 대신 `yield`를 사용하는 함수이다. `return`은 결과값을 반환하고 함수가 종료되지만, `yield`는 결과값을 반환하는 동시에 실행 상태를 저장해 둔채 잠시 멈춘다. 따라서 나중에 다시 이전에 멈춘 상태에서 다음 코드 실행이 가능해진다.
## 제너레이터 예제
```
def num_gen():
    for i in range(3):
        yield i


g = num_gen()       # 제너레이터 객체 생성 

num1 = next(g)
num2 = next(g)
num3 = next(g)

print(num1, num2, num3)

0, 1, 2
```
`yield`가 사용된 함수는 ()를 사용해 호출해도 바로 실행되지 않는다. 대신 제너레이터 객체가 생성되고 코드가 실행될 준비를 한다. 제너레이터 객체가 생성되면 `next()` 함수 호출을 통해 제너레이터 객체 내의 코드를 실행할 수 있는데, 이때 `yield` 구문을 만나면 파이썬 함수의 `return` 처럼 `yield` 키워드에 있는 값을 호출부로 반환하고 실행의 흐름도 호출부로 이동한다.
***
```
def num_gen():
    for i in range(3):
        yield i

g = num_gen()
print(next(g))
print(next(g))
print(next(g))
print(next(g))

0
1
2
StopIteration
```
위 코드에서 `range(3)`으로 지정했기 때문에 2까지 반환할 수 있다. 이때 `next(g)`를 실행하는 경우 반환할 값이 존재하지 않으므로 `StopIteration` 오류가 발생한다.
```
def num_gen():
    for i in range(3):
        yield i

g = num_gen()

for i in g:
    print(i)
    
0
1
2
```
`for`문을 사용하여 표현할 수 있다.
## 제너레이터 사용 이유
프로그램을 개발할 때 처리해야 하는 숫자가 커질수록 사용되는 메모리는 증가한다. 이런 문제 때문에 작은 데이터에서는 잘 동작하는 프로그램이 큰 규모의 데이터셋에서는 제대로 동작하지 않거나 매우 느리게 동작하는 경우가 있다. 제너레이터를 사용하면 한 번에 데이터를 모아서 처리하지 않기 때문에 큰 메모리를 사용하지 않아도 되는데 이는 규모가 있는 프로그램을 개발할 때 매우 중요한 요소이다.

즉 제너레이터는 큰 규모의 확장성이 있는 프로그램을 개발하기 위해 사용한다.
